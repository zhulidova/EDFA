clear all;
% P_s_sum         - суммарна€ мощность сигнала, дЅм
% P_in.S          - массив входных мощностей сигнала (суммарна€ мощность / кол-во длин волн), дЅм
% P_in.PF         - массив мощностей попутной накачки в 0, дЅм
% P_in.PB         - массив мощностей встречного ASE (на заданном массиве длин волн) в L, дЅм
%пустой массив, если накачка только попуна€
% r_edf           - радиус сердцевины активного волокна, м
% NA              - числова€ апертура активного волокна    
% n               - концентраци€ ионов эрби€, ppm
% L               - длина активного волокна, м
% T_c             - температура среды, ∞—
% low_gain_regime - механический выбор режима слабого сигнала (упрощенна€ система уравнений),
%0 - общий случай (без приближени€), 1 - режим слабого сигнала

% ‘ункции
% edfa_main       - основна€ расчетна€ функци€ EDFA
% smooth_res      - сглаживание результатов
% create_graf     - построение графиков 

P_s_sum = [10];  % массив суммарных входных мощностей сигнала  
% параметры сигнала 
Lambda.s              = [1529.55 1532.70 1538.20 1543.80 1546.90 1551.70 1557.40 1560.60] * 10^(-9); % длины волн сигнала, нм
Pin.s                 = watt(P_s_sum) / length(Lambda.s) * ones(1,length(Lambda.s));        % входные мощности сигнала, дЅм

% параметры ASE 
Lambda_range          = [1528 1565] * 10^(-9);                           % спектр ASE, нм

% параметры накачки
Lambda.pf             = [1473 1480] * 10^(-9);                           % длины волн попутной накачки, нм
Pin.pf                = watt([13.85 15.89]);

Lambda.pb             = [] * 10^(-9);                                    % длины волн встречной накачки, нм
                                                                         % (пустой массив, если накачка только попутна€)
Pin.pb                = [];                                              % входные мощности встречной накачки, дЅм

L    = 9;
N0.r                  = 25;
N0.ase                = 20;
N0.z                  = 50;
type                  = 'OFS980';
%% ќсновна€ расчетна€ функци€
[z, P, Gain, OSNR, NF, SPase]   = edfa(Pin, Lambda, Lambda_range, L, N0, type, T_c);
% сглаживание результатов моделировани€
[wl_smooth.Model, G_smooth.Model, nf_smooth.Model] = smooth_res(Lambda.s', Gain, NF);   

% чтение экспериментальных данных
EXP   = exp_res(P_s_sum(i), T_c, dbm(sum(Pin.pf)));

[wl_smooth.Exp, G_smooth.Exp, nf_smooth.Exp]  = smooth_res(EXP(1,:), EXP(2,:), EXP(3,:));


 end
 end
%% оформление графиков
create_graf(wl_smooth.Model*10^9, G_smooth.Model, "model", 'Gain', P_s_sum, Pin, 1, 1); 
hold on;
create_graf(EXP(1,:), EXP(2,:), "exp", 'Gain', P_s_sum, Pin, 1, 1); 
hold on;
create_graf(wl_smooth.Model*10^9, nf_smooth.Model, "model", 'NF', P_s_sum, Pin, 2, 1); 
hold on;
create_graf(EXP(1,:), EXP(3,:), "exp", 'NF', P_s_sum, Pin, 2, 1);
hold on;
