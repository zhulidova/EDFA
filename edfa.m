%% Входные параметры
% •	Pin – структура, состоящая из массивов входных мощностей сигналов, попутных и встречных накачек.
% •	Lambda – структура, состоящая из массивов значений соответствующих длин волн для сигналов, попутных и встречных накачек. 
% •	Lambda_range – массив, значения которого задают границы диапазона длин волн для расчета шума   
% •	L – длина активного волокна 
% •	Type – параметр, указывающий на используемый тип волокна (параметры активного волокна). 
% •	N0 – структура, содержащая значения количества точек разбиения диапазона длин волн для расчета шума, количества точек дискретизации 
% радиуса сердцевины волокна (шаг интегрирования по радиусу), количества точек дискретизации длины волокна (предварительный шаг интегрирования по 
% длине волокна). 
%
% Шаблон 
% Pin.s = []*10^(-3);     % Мощности сигналов, Вт
% Lambda.s = []*10^(-9);  % Длины волн сигналов, м
% Pin.pf = []*10^(-3);    % Мощности попутных накачек, Вт
% Lambda.pf = []*10^(-9); % Длины волн попутных накачек, м
% Pin.pb = []*10^(-3);    % Мощности встречных накачек, Вт
% Lambda.pb = []*10^(-9); % Длины волн встречных накачек, м
% Lambda_range = [1528 1565]*10^(-9); % Диапазон длин волн для расчета шума, м
% L = [];                 % Длина активного волокна, м
% N.ase = 20;             % Число точек по длине волны (для расчета шума) 
% N.z = 50;               % Число точек по z (для интегрирования)
% N.r = 25;               % Число точек по r
% type = 'OFS980';        % Тип активного волокна

%% Выходные параметры
% •	z – массив значений длины волокна, на которых производился расчет параметров. 
% •	P – структура, состоящая из массивов значений мощностей сигналов, попутных и встречных накачек,
% попутных и встречных шумов, структура распределения мощностей по z. Мощность в Вт. 
% •	Gain – массив значений коэффициентов усиления для соответствующих
% входных сигналов, dB
% •	OSNR – массив значений соотношений сигнал/шум для соответствующих входных сигналов, dB  
% •	NF – массив значений шум-фактора для соответствующих входных сигналов.
% dB
% •	SPase – спектр шума (зависимость мощности шума от длины волны)

%% Функции
% concentration(...) - функция пересчета концентрации из ppm в м^(-3)
% sigma_lum(...)     - функция расчета сечений поглощения и люминесценции для каждой длины волны 
%при определенной температуре
% bessel(...)        - функция расчета функций распередения интенсивности по радиусу волокна для
%каждой дины волны (зависит от радиуса сердцевины и числовой апертуры активного волокна)
% splice_loss(...)   - функция расчета реальных входных мощностей сигнала и накачки с учетом потерь
%на сварках и WDM
% ase_in(...)        - функция расчета начальных значений мощности ASE
% odu2_unsaturated_gain_regime(...) - функция расчета значений производных для скоростных уравнений в приближении
%слабого сигнала 
% odu2(...)          - функция расчета значений производных для скоростных уравнений в общем случае 
% chord_method(...)  - функция с линейной интерполяцией начальных условий для сведения комбинированного
%случая или случая со встречной накачкой к задаче Коши 
% gain(...)          - функция расчета коэффициента усиления
% nf(...)            - функция расчета шум-фактора

function [z, P, Gain, OSNR, NF, SPase] = edfa(Pin, Lambda, Lambda_range, L, N0, type) 

% Физические константы
ph_const.c      = 299792458;                                         % скорость света    
ph_const.h      = 6.626E-34;                                         % постоянная Планка
ph_const.tau    = 0.0102;                                            % время жизни на верхнем уровне
ph_const.k      = 1.38 * 10^(-23);                                   % постоянная Больцмана
ph_const.eV     = 1.602 * 10^(-19);                                  % 1 эВ в Дж

% параметры активного волокна
if strcmp(type,'OFS980')==1
    r_edf       = 2.9E-6 / 2;                                        % радиус сердцевины, м
    NA          = 0.26;                                              % числовая апертура активного волокна
    n           = 70;                                                % концентрация ионов эрбия, ppm
end 

% параметры системы
T_c             = 25;                                                 % температура среды, °С
splices.wdm_p   = 2.35;                                              % потери на wdm для накачки (datasheet), дБм                         
splices.wdm_s   = 0.2;                                               % потери на wdm для сигнала (datasheet), дБм                  
splices.fiber   = 0.5;                                               % потери на сварке
low_gain_regime = 0;                                                 % механический выбор режима слабого сигнала
% 1 - режим слабого сигнала % 0 - общий случай

% расчет параметров для ОДУ
T               = 273.15 + T_c;                                      % температура в кельвинах
n_sum           = concentration(n);                                  % концентрация в м^(-3)
N.s             = length(Lambda.s);                                  % размер массива длин волн сигнала
N.pf            = length(Lambda.pf);                                 % размер массива длин волн попутной накачки
N.ase           = N0.ase;                                            % размер массива длин волн ASE
N.pb            = length(Lambda.pb);                                 % размер массива длин встречной накачки
Lambda.ase      = ase_diskr(N.ase,Lambda_range);                     % расчет начальных значений мощности ASE
sigma           = sigma_lum(T, Lambda, ph_const);                    % расчет сечений
[psi, w_edf]    = bessel(r_edf, Lambda, N, NA, N0.r);                % волновые функции интенсивности главной моды

%% учет доп. потерь  

[Pin.s, Pin.pf] = splice_loss(dbm(Pin.s), dbm(Pin.pf), Lambda, r_edf, splices, NA); 
Pin.asef        = ase_in(Lambda, ph_const, sigma, Pin.pf, w_edf);

%% решение сиситемы ОДУ
    tStart = cputime;                   % старт таймера
    if isempty(Pin.pb) == 1 
    % случай только попуной накачки (задача Коши)
        if low_gain_regime == 1
        % решение упрощенной системы уравнений (режим слабого сигнала)
            [z, Pout]   = ode45(@(z,P) odu2_unsaturated_gain_regime(z, P, Lambda, sigma, N, w_edf, n_sum, ph_const, Pin), [0: L/N0.z: L],[Pin.s Pin.asef  Pin.pf]);
        else
        % решение подробной системы уравнений (общий случай)
            [z, Pout]   = ode45(@(z,P) odu2(z, P, Lambda, sigma, psi, N, n_sum, ph_const, Pin, r_edf, N0), [0: L/N0.z: L],[Pin.s Pin.asef Pin.pf]);
        end
    else
        % случай встречной накачки или комбинированный случай
        Pin.aseb        = ase_in(Lambda,ph_const, sigma,Pin.pb, w_edf);
        [z, Pout]       = chord_method(L, Lambda, sigma, psi, N, w_edf, n_sum, Pin, low_gain_regime, ph_const, r_edf, N0); 
    end
    Pout       = Pout / undb(splices.fiber); % реальные выходные мощности сигнала и накачки
    
    z          = z';   % Массив значений z
    % P - структура распределения мощностей по z
    P.s        = Pout(:, 1: N.s)';                      % Распределение мощностей сигналов
    Pspec.s    = P.s(:, size(P.s,2));                   % Спектр мощности сигнала в конце волокна
    P.asef     = Pout(:, N.s+1: N.s+N.ase)';            % Распределение мощности попутных шумов
    Pspec.asef = P.asef(:, size(P.asef,2));             % Спектр мощности попутных шумов
    P.pf       = Pout(:, N.s+N.ase+1: N.s+N.ase+N.pf)'; % Распределение мощностей попутных накачек
    Pspec.pf   = P.pf(:, size(P.pf,2));                 % Спектр мощности попутных накачек

    if isempty(Pin.pb) == 0
        P.aseb     = Pout(:, N.s+N.ase+N.pf+1: N.s+2*N.ase+N.pf)';        % Распределение мощности встречных шумов
        Pspec.aseb = P.aseb(:, size(P.aseb,2));                           % Спектр мощности встречных шумов
        P.pb       = Pout(:, N.s+2*N.ase+N.pf+1: N.s+2*N.ase+N.pf+N.pb)'; % Распределение мощностей встречных накачек
        Pspec.pb   = P.pb(:, size(P.pb,2));                               % Спектр мощности встречных накачек

    end
    
    Gain         = gain(Pspec.s, Pin.s');                           % расчет Gain
    [OSNR, NF]   = nf(Pspec.asef, Gain, Lambda, ph_const, Pspec.s); % расчет NF и OSNR_out
    SPase.lambda = Lambda.ase';                                     % спектр ASE
    SPase.p      = dbm(Pspec.asef);
    
    time         = cputime - tStart;                                % конец таймера
    formatSpec   = 'Система ОДУ для EDFA решена за %f секунд\n';                           
    fprintf(formatSpec,time)
    
end