clear all; clc;
% P_s_sum         - суммарна€ мощность сигнала, дЅм
% P_in.S          - массив входных мощностей сигнала (суммарна€ мощность / кол-во длин волн), дЅм
% P_in.PF         - массив мощностей попутной накачки в 0, дЅм
% P_in.PB         - массив мощностей встречного ASE (на заданном массиве длин волн) в L, дЅм
%пустой массив, если накачка только попуна€
% r_edf           - радиус сердцевины активного волокна, м
% NA              - числова€ апертура активного волокна    
% n               - концентраци€ ионов эрби€, ppm
% L               - длина активного волокна, м
% T_c             - температура среды, ∞—
% low_gain_regime - механический выбор режима слабого сигнала (упрощенна€ система уравнений),
%0 - общий случай (без приближени€), 1 - режим слабого сигнала

% ‘ункции
% edfa_main       - основна€ расчетна€ функци€ EDFA
% smooth_res      - сглаживание результатов
% create_graf     - построение графиков 
    
P_s_sum = -28;  % массив суммарных входных мощностей сигнала  
% параметры сигнала 
Lambda.s              = [1529.52 1532.672	1534.256	1536.568	1538.144	1542.184	1543.736	1546.896	1550.08	1551.712	1554.088	1557.304	1558.936	1560.568	1562.2	1564.65]* 10^(-9); % длины волн сигнала, нм
Pin.s                 = watt(P_s_sum) / length(Lambda.s) * ones(1,length(Lambda.s));        % входные мощности сигнала, дЅм

% параметры ASE 
Lambda_range          = [1528 1565] * 10^(-9);                           % спектр ASE, нм

% параметры накачки
Lambda.pf             = [1473 1480] * 10^(-9);                           % длины волн попутной накачки, нм
Pin.pf                = watt([5.95 7.98]);

Lambda.pb             = [];                                               % длины волн встречной накачки, нм
                                                                         % (пустой массив, если накачка только попутна€)
Pin.pb                = [];                                              % входные мощности встречной накачки, дЅм

L    = 9;
N0.r                  = 25;
N0.ase                = 50;
N0.z                  = 50;
type                  = 'ROPA1';

T_c = 25;

%% ќсновна€ расчетна€ функци€
[z, P, Gain, OSNR, NF, SPase]   = edfa(Pin, Lambda, Lambda_range, L, N0, type, T_c);
Pout = dbm(P.s);

% сглаживание результатов моделировани€
[wl_smooth.Model, G_smooth.Model, nf_smooth.Model] = smooth_res(Lambda.s', Gain, NF); 
% чтение экспериментальных данных

create_graf(wl_smooth.Model*10^9, G_smooth.Model,0, "model", 'Gain', P_s_sum, Pin, 1, 1, T_c); 
hold on;

